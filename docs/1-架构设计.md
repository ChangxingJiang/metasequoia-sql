# metasequoia-sql 架构设计

## 词法解析器与句法解析器分离

在 SQL 语句的解析过程中，包含明显的两个过程：

1. 将以字符为单位的字符串，解析为以词法元素为单位的词法树
2. 将以词法元素为单位的词法树，解析为以语法节点为单位的抽象语法树

我们在设计中，基于以下目的，令这两个过程相互独立：

- 解耦：避免令字符串解析与语法解析耦合在一起，导致需要兼容的特殊场景几何级数增加
- 提效：将语法逻辑从词法解析的状态机（可以将正则表达式也视作一种状态机）中分离出来，从而使对语法解析状态机的优化成为可能。降低在部分无法避免的重复匹配场景下的资源消耗，例如进行两次字符串是否相等的判断，要比从字符串中解析两次字符串进行比较要简单。

具体地，词法解析器的逻辑在 `metasequoia_sql.lexical` 中，语法解析的逻辑在 `metasequoia.core` 中。

## 使用单一、独立的状态机实现词法解析

在词法解析的实现上，我们使用了单一的有限状态自动机（`FSMMachine`），状态机的状态及数据存储在缓存器（`FSMMemory`）中。

在词法解析时（`FSMMachien.parse(text)`），遍历 SQL 字符串，对于每一个字符，基于状态和字符选择执行器（`FSMOperate`  的子类）并执行。执行器会可以更新缓存器中的状态以及存储的数据。

通过以上设计，我们旨在达到以下目的：

- 避免大量不同的正则表达式存在，提高可读性
- 将多个正则表达式的状态机合并为一个，从根本上避免了重复遍历的可能，提高性能
- 使将更多的执行器选择的逻辑可以被预处理，提高性能
- 通过一个字典（`FSM_OPERATION_MAP`）实现状态转移设置，方便修改和插件开发
- 方便未来迁移到 C 实现，进一步提高效率

## 语法解析为嵌套的一元、二元表达式

除 `FROM` 多个表、`GROUP BY` 多个字段等在语法上确实并列的场景外，我们将其他 SQL 语法均解析为嵌套的一元表达式或二元表达式。

通过这个设计，旨在达到以下目的：

- 将计算优先级直接在抽象语法树中通过嵌套关系表示出来，从而避免在使用抽象语法树时，还需要根据计算优先级进行重复解析
- 令每个抽象语法树节点都是可直接执行的，方便基于抽象语法树实现 SQL 运行
- 方便在递归分析时，根据节点类型直接开发处理逻辑
